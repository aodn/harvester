// ============================================================================
//
// Copyright (c) 2005-2012, Talend Inc.
//
// This source code has been automatically generated by_Talend Open Studio for Data Integration
// / JobDesigner (CodeGenerator version 5.1.3.r96646)
// You can find more information about Talend products at www.talend.com.
// You may distribute this code under the terms of the GNU LGPL license
// http://www.gnu.org/licenses/lgpl.html).
//
// ============================================================================
package anfog_dm.harvestmetadatafilesystem_rt_0_1;

import routines.DataOperation;
import routines.OpenStreetMap;
import routines.TalendDataGenerator;
import routines.GeometryUtility;
import routines.Numeric;
import routines.NetCDFUtils;
import routines.GeoOperation;
import routines.DAPUtils;
import routines.Mathematical;
import routines.ArgoUtils;
import routines.Relational;
import routines.TalendDate;
import routines.GeometryOperation;
import routines.TalendString;
import routines.StringHandling;
import routines.system.*;
import routines.system.api.*;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.math.BigDecimal;
import java.io.ByteArrayOutputStream;
import java.io.ByteArrayInputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.ObjectOutputStream;
import java.io.ObjectInputStream;
import java.io.IOException;
import java.util.Comparator;

@SuppressWarnings("unused")
/**
 * Job: HarvestMetadataFileSystem_RT Purpose: <br>
 * Description:  <br>
 * @author test@talend.com
 * @version 5.1.3.r96646
 * @status 
 */
public class HarvestMetadataFileSystem_RT implements TalendJob {

	public final Object obj = new Object();

	// for transmiting parameters purpose
	private Object valueObject = null;

	public Object getValueObject() {
		return this.valueObject;
	}

	public void setValueObject(Object valueObject) {
		this.valueObject = valueObject;
	}

	private final static String defaultCharset = java.nio.charset.Charset
			.defaultCharset().name();

	private final static String utf8Charset = "UTF-8";

	// create and load default properties
	private java.util.Properties defaultProps = new java.util.Properties();

	// create application properties with default
	public class ContextProperties extends java.util.Properties {

		private static final long serialVersionUID = 1L;

		public ContextProperties(java.util.Properties properties) {
			super(properties);
		}

		public ContextProperties() {
			super();
		}

		public void synchronizeContext() {

			if (logDir != null) {

				this.setProperty("logDir", logDir.toString());

			}

			if (paramFile != null) {

				this.setProperty("paramFile", paramFile.toString());

			}

			if (metadataDb_RT_Database != null) {

				this.setProperty("metadataDb_RT_Database",
						metadataDb_RT_Database.toString());

			}

			if (metadataDb_RT_Login != null) {

				this.setProperty("metadataDb_RT_Login", metadataDb_RT_Login
						.toString());

			}

			if (metadataDb_RT_Password != null) {

				this.setProperty("metadataDb_RT_Password",
						metadataDb_RT_Password.toString());

			}

			if (metadataDb_RT_Port != null) {

				this.setProperty("metadataDb_RT_Port", metadataDb_RT_Port
						.toString());

			}

			if (metadataDb_RT_Schema != null) {

				this.setProperty("metadataDb_RT_Schema", metadataDb_RT_Schema
						.toString());

			}

			if (metadataDb_RT_Server != null) {

				this.setProperty("metadataDb_RT_Server", metadataDb_RT_Server
						.toString());

			}

			if (exclude != null) {

				this.setProperty("exclude", exclude.toString());

			}

			if (fileId != null) {

				this.setProperty("fileId", fileId.toString());

			}

			if (include != null) {

				this.setProperty("include", include.toString());

			}

			if (sourceDir != null) {

				this.setProperty("sourceDir", sourceDir.toString());

			}

			if (url != null) {

				this.setProperty("url", url.toString());

			}

		}

		public String logDir;

		public String getLogDir() {
			return this.logDir;
		}

		public String paramFile;

		public String getParamFile() {
			return this.paramFile;
		}

		public String metadataDb_RT_Database;

		public String getMetadataDb_RT_Database() {
			return this.metadataDb_RT_Database;
		}

		public String metadataDb_RT_Login;

		public String getMetadataDb_RT_Login() {
			return this.metadataDb_RT_Login;
		}

		public java.lang.String metadataDb_RT_Password;

		public java.lang.String getMetadataDb_RT_Password() {
			return this.metadataDb_RT_Password;
		}

		public String metadataDb_RT_Port;

		public String getMetadataDb_RT_Port() {
			return this.metadataDb_RT_Port;
		}

		public String metadataDb_RT_Schema;

		public String getMetadataDb_RT_Schema() {
			return this.metadataDb_RT_Schema;
		}

		public String metadataDb_RT_Server;

		public String getMetadataDb_RT_Server() {
			return this.metadataDb_RT_Server;
		}

		public String exclude;

		public String getExclude() {
			return this.exclude;
		}

		public Long fileId;

		public Long getFileId() {
			return this.fileId;
		}

		public String include;

		public String getInclude() {
			return this.include;
		}

		public String sourceDir;

		public String getSourceDir() {
			return this.sourceDir;
		}

		public String url;

		public String getUrl() {
			return this.url;
		}
	}

	private ContextProperties context = new ContextProperties();

	public ContextProperties getContext() {
		return this.context;
	}

	private final String jobVersion = "0.1";
	private final String jobName = "HarvestMetadataFileSystem_RT";
	private final String projectName = "ANFOG_DM";
	public Integer errorCode = null;
	private String currentComponent = "";
	private final java.util.Map<String, Long> start_Hash = new java.util.HashMap<String, Long>();
	private final java.util.Map<String, Long> end_Hash = new java.util.HashMap<String, Long>();
	private final java.util.Map<String, Boolean> ok_Hash = new java.util.HashMap<String, Boolean>();
	private final java.util.Map<String, Object> globalMap = new java.util.HashMap<String, Object>();
	public final java.util.List<String[]> globalBuffer = new java.util.ArrayList<String[]>();

	public boolean isExportedAsOSGI = false;

	private final java.io.ByteArrayOutputStream baos = new java.io.ByteArrayOutputStream();
	private final java.io.PrintStream errorMessagePS = new java.io.PrintStream(
			new java.io.BufferedOutputStream(baos));

	public String getExceptionStackTrace() {
		if ("failure".equals(this.getStatus())) {
			errorMessagePS.flush();
			return baos.toString();
		}
		return null;
	}

	private java.lang.Exception exception = null;

	public java.lang.Exception getException() {
		if ("failure".equals(this.getStatus())) {
			return this.exception;
		}
		return null;
	}

	private class TalendException extends java.lang.Exception {

		private static final long serialVersionUID = 1L;

		private java.util.Map<String, Object> globalMap = null;
		private java.lang.Exception e = null;
		private String currentComponent = null;

		private TalendException(java.lang.Exception e, String errorComponent,
				final java.util.Map<String, Object> globalMap) {
			this.currentComponent = errorComponent;
			this.globalMap = globalMap;
			this.e = e;
		}

		public java.lang.Exception getException() {
			return this.e;
		}

		public String getCurrentComponent() {
			return this.currentComponent;
		}

		@Override
		public void printStackTrace() {
			if (!(e instanceof TalendException || e instanceof TDieException)) {
				globalMap.put(currentComponent + "_ERROR_MESSAGE", e
						.getMessage());
				System.err
						.println("Exception in component " + currentComponent);
			}
			if (!(e instanceof TDieException)) {
				if (e instanceof TalendException) {
					e.printStackTrace();
				} else {
					e.printStackTrace();
					e.printStackTrace(errorMessagePS);
					HarvestMetadataFileSystem_RT.this.exception = e;
				}
			}
			if (!(e instanceof TalendException)) {
				try {
					for (java.lang.reflect.Method m : this.getClass()
							.getEnclosingClass().getMethods()) {
						if (m.getName().compareTo(currentComponent + "_error") == 0) {
							m.invoke(HarvestMetadataFileSystem_RT.this,
									new Object[] { e, currentComponent,
											globalMap });
							break;
						}
					}

					if (!(e instanceof TDieException)) {
					}
				} catch (java.lang.SecurityException e) {
					this.e.printStackTrace();
				} catch (java.lang.IllegalArgumentException e) {
					this.e.printStackTrace();
				} catch (java.lang.IllegalAccessException e) {
					this.e.printStackTrace();
				} catch (java.lang.reflect.InvocationTargetException e) {
					this.e.printStackTrace();
				}
			} else {

				status = "failure";

			}
		}
	}

	public void iPostgresqlDbUpdate_1_error(java.lang.Exception exception,
			String errorComponent, final java.util.Map<String, Object> globalMap)
			throws TalendException {
		end_Hash.put("iPostgresqlDbUpdate_1", System.currentTimeMillis());

		status = "failure";

		iPostgresqlDbUpdate_1_onSubJobError(exception, errorComponent,
				globalMap);
	}

	public void iHarvestResources_1_error(java.lang.Exception exception,
			String errorComponent, final java.util.Map<String, Object> globalMap)
			throws TalendException {
		end_Hash.put("iHarvestResources_1", System.currentTimeMillis());

		status = "failure";

		iHarvestResources_1_onSubJobError(exception, errorComponent, globalMap);
	}

	public void iDeletedResources_1_error(java.lang.Exception exception,
			String errorComponent, final java.util.Map<String, Object> globalMap)
			throws TalendException {
		end_Hash.put("iDeletedResources_1", System.currentTimeMillis());

		status = "failure";

		iDeletedResources_1_onSubJobError(exception, errorComponent, globalMap);
	}

	public void tRunJob_2_error(java.lang.Exception exception,
			String errorComponent, final java.util.Map<String, Object> globalMap)
			throws TalendException {
		end_Hash.put("tRunJob_2", System.currentTimeMillis());

		status = "failure";

		iDeletedResources_1_onSubJobError(exception, errorComponent, globalMap);
	}

	public void tRunJob_1_error(java.lang.Exception exception,
			String errorComponent, final java.util.Map<String, Object> globalMap)
			throws TalendException {
		end_Hash.put("tRunJob_1", System.currentTimeMillis());

		status = "failure";

		iHarvestResources_1_onSubJobError(exception, errorComponent, globalMap);
	}

	public void iIndexFiles_2_iFiles_error(java.lang.Exception exception,
			String errorComponent, final java.util.Map<String, Object> globalMap)
			throws TalendException {
		end_Hash.put("iIndexFiles_2_iFiles", System.currentTimeMillis());

		status = "failure";

		iIndexFiles_2_iFiles_onSubJobError(exception, errorComponent, globalMap);
	}

	public void iIndexFiles_2_iIndexer_error(java.lang.Exception exception,
			String errorComponent, final java.util.Map<String, Object> globalMap)
			throws TalendException {
		end_Hash.put("iIndexFiles_2_iIndexer", System.currentTimeMillis());

		status = "failure";

		iIndexFiles_2_iFiles_onSubJobError(exception, errorComponent, globalMap);
	}

	public void iPostgresqlDbUpdate_1_onSubJobError(
			java.lang.Exception exception, String errorComponent,
			final java.util.Map<String, Object> globalMap)
			throws TalendException {

		resumeUtil.addLog("SYSTEM_LOG", "NODE:" + errorComponent, "", Thread
				.currentThread().getId()
				+ "", "FATAL", "", exception.getMessage(), ResumeUtil
				.getExceptionStackTrace(exception), "");

	}

	public void iHarvestResources_1_onSubJobError(
			java.lang.Exception exception, String errorComponent,
			final java.util.Map<String, Object> globalMap)
			throws TalendException {

		resumeUtil.addLog("SYSTEM_LOG", "NODE:" + errorComponent, "", Thread
				.currentThread().getId()
				+ "", "FATAL", "", exception.getMessage(), ResumeUtil
				.getExceptionStackTrace(exception), "");

	}

	public void iDeletedResources_1_onSubJobError(
			java.lang.Exception exception, String errorComponent,
			final java.util.Map<String, Object> globalMap)
			throws TalendException {

		resumeUtil.addLog("SYSTEM_LOG", "NODE:" + errorComponent, "", Thread
				.currentThread().getId()
				+ "", "FATAL", "", exception.getMessage(), ResumeUtil
				.getExceptionStackTrace(exception), "");

	}

	public void iIndexFiles_2_iFiles_onSubJobError(
			java.lang.Exception exception, String errorComponent,
			final java.util.Map<String, Object> globalMap)
			throws TalendException {

		resumeUtil.addLog("SYSTEM_LOG", "NODE:" + errorComponent, "", Thread
				.currentThread().getId()
				+ "", "FATAL", "", exception.getMessage(), ResumeUtil
				.getExceptionStackTrace(exception), "");

	}

	private ESBProviderCallback callback = null;

	public void setProviderCallback(ESBProviderCallback callback) {
	}

	public ESBEndpointInfo getEndpoint() {
		return null;
	}

	public void iPostgresqlDbUpdate_1Process(
			final java.util.Map<String, Object> globalMap)
			throws TalendException {
		globalMap.put("iPostgresqlDbUpdate_1_SUBPROCESS_STATE", 0);

		final boolean execStat = this.execStat;

		String iterateId = "";
		String currentComponent = "";

		try {

			String currentMethodName = new java.lang.Exception()
					.getStackTrace()[0].getMethodName();
			boolean resumeIt = currentMethodName.equals(resumeEntryMethodName);
			if (resumeEntryMethodName == null || resumeIt || globalResumeTicket) {// start
																					// the
																					// resume
				globalResumeTicket = true;

				/**
				 * [iPostgresqlDbUpdate_1 begin ] start
				 */

				ok_Hash.put("iPostgresqlDbUpdate_1", false);
				start_Hash.put("iPostgresqlDbUpdate_1", System
						.currentTimeMillis());
				currentComponent = "iPostgresqlDbUpdate_1";

				int tos_count_iPostgresqlDbUpdate_1 = 0;
				java.io.File tempFile_iPostgresqlDbUpdate_1 = null;
				java.io.PrintStream out_iPostgresqlDbUpdate_1 = null;
				java.io.File tempDir_iPostgresqlDbUpdate_1 = null;

				try {
					System.out.println("Start of try block");
					tempDir_iPostgresqlDbUpdate_1 = java.io.File
							.createTempFile("talend-temp-", "");
					tempDir_iPostgresqlDbUpdate_1.delete();
					tempDir_iPostgresqlDbUpdate_1.mkdir();

					tempFile_iPostgresqlDbUpdate_1 = new java.io.File(
							tempDir_iPostgresqlDbUpdate_1, "changelog.xml");

					System.out.println("tempFile_cid "
							+ tempFile_iPostgresqlDbUpdate_1);

					out_iPostgresqlDbUpdate_1 = new java.io.PrintStream(
							new java.io.FileOutputStream(
									tempFile_iPostgresqlDbUpdate_1));
					out_iPostgresqlDbUpdate_1
							.print("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n"
									+ "<databaseChangeLog xmlns=\"http://www.liquibase.org/xml/ns/dbchangelog\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-2.0.xsd\">\n"
									+ "\n"
									+ "    <changeSet author=\"talend\" id=\"1375428625889-1\">\n"
									+ "        <createTable tableName=\"attribute\">\n"
									+ "            <column name=\"file_id\" type=\"int8\">\n"
									+ "                <constraints nullable=\"false\"/>\n"
									+ "            </column>\n"
									+ "            <column name=\"container\" type=\"TEXT\">\n"
									+ "                <constraints nullable=\"false\"/>\n"
									+ "            </column>\n"
									+ "            <column name=\"name\" type=\"TEXT\">\n"
									+ "                <constraints nullable=\"false\"/>\n"
									+ "            </column>\n"
									+ "            <column name=\"type\" type=\"TEXT\"/>\n"
									+ "            <column name=\"value\" type=\"TEXT\"/>\n"
									+ "        </createTable>\n"
									+ "    </changeSet>\n"
									+ "    \n"
									+ "    <changeSet author=\"talend\" id=\"1375428625889-2\">\n"
									+ "        <createTable tableName=\"file\">\n"
									+ "            <column name=\"file_id\" type=\"int8\">\n"
									+ "                <constraints nullable=\"false\" primaryKey=\"true\" primaryKeyName=\"file_pk\"/>\n"
									+ "            </column>\n"
									+ "            <column name=\"url\" type=\"TEXT\"/>\n"
									+ "        </createTable>\n"
									+ "    </changeSet>\n"
									+ "    \n"
									+ "    <changeSet author=\"talend\" id=\"1375428625889-6\">\n"
									+ "        <createTable tableName=\"variable\">\n"
									+ "            <column name=\"file_id\" type=\"int8\">\n"
									+ "                <constraints nullable=\"false\"/>\n"
									+ "            </column>\n"
									+ "            <column name=\"name\" type=\"TEXT\">\n"
									+ "                <constraints nullable=\"false\"/>\n"
									+ "            </column>\n"
									+ "            <column name=\"type\" type=\"TEXT\"/>\n"
									+ "            <column name=\"dimensions\" type=\"TEXT\"/>\n"
									+ "            <column name=\"shape\" type=\"TEXT\"/>\n"
									+ "        </createTable>\n"
									+ "    </changeSet>\n"
									+ "    \n"
									+ "    <changeSet author=\"talend\" id=\"1375428625889-7\">\n"
									+ "        <addPrimaryKey columnNames=\"file_id, container, name\" constraintName=\"attribute_pk\" tableName=\"attribute\"/>\n"
									+ "    </changeSet>\n"
									+ "    \n"
									+ "    <changeSet author=\"talend\" id=\"1375428625889-8\">\n"
									+ "        <addPrimaryKey columnNames=\"file_id, name\" constraintName=\"variable_pk\" tableName=\"variable\"/>\n"
									+ "    </changeSet>\n"
									+ "    \n"
									+ "</databaseChangeLog>");
					out_iPostgresqlDbUpdate_1.flush();

					String fileName_iPostgresqlDbUpdate_1 = "changelog.xml";
					String basePath_iPostgresqlDbUpdate_1 = tempDir_iPostgresqlDbUpdate_1
							.getAbsolutePath();

					System.out.println("***********************");
					System.out.println("conn host:"
							+ context.metadataDb_RT_Server + ", port:"
							+ context.metadataDb_RT_Port + ", schema:"
							+ context.metadataDb_RT_Schema + ", name:"
							+ context.metadataDb_RT_Database + ", user:"
							+ context.metadataDb_RT_Login);

					String url_iPostgresqlDbUpdate_1 = "jdbc:postgresql://"
							+ context.metadataDb_RT_Server + ":"
							+ context.metadataDb_RT_Port + "/"
							+ context.metadataDb_RT_Database;

					String schema_iPostgresqlDbUpdate_1 = context.metadataDb_RT_Schema;

					String userName_iPostgresqlDbUpdate_1 = context.metadataDb_RT_Login;
					String password_iPostgresqlDbUpdate_1 = context.metadataDb_RT_Password;

					System.out.println("url_cid:" + url_iPostgresqlDbUpdate_1);
					System.out.println("schema_cid:"
							+ schema_iPostgresqlDbUpdate_1);
					System.out.println("userName_cid:"
							+ userName_iPostgresqlDbUpdate_1);

					java.sql.Connection conn_iPostgresqlDbUpdate_1 = null;
					liquibase.Liquibase liquibase_iPostgresqlDbUpdate_1 = null;

					try {
						java.lang.Class.forName("org.postgresql.Driver");
						conn_iPostgresqlDbUpdate_1 = java.sql.DriverManager
								.getConnection(url_iPostgresqlDbUpdate_1,
										userName_iPostgresqlDbUpdate_1,
										password_iPostgresqlDbUpdate_1);
						conn_iPostgresqlDbUpdate_1.setAutoCommit(false);

						liquibase.database.Database database_iPostgresqlDbUpdate_1 = liquibase.database.DatabaseFactory
								.getInstance()
								.findCorrectDatabaseImplementation(
										new liquibase.database.jvm.JdbcConnection(
												conn_iPostgresqlDbUpdate_1));
						database_iPostgresqlDbUpdate_1
								.setDefaultSchemaName(schema_iPostgresqlDbUpdate_1);
						liquibase_iPostgresqlDbUpdate_1 = new liquibase.Liquibase(
								fileName_iPostgresqlDbUpdate_1,
								new liquibase.resource.FileSystemResourceAccessor(
										basePath_iPostgresqlDbUpdate_1),
								database_iPostgresqlDbUpdate_1);

						liquibase_iPostgresqlDbUpdate_1.update(null);
					} finally {
						if (conn_iPostgresqlDbUpdate_1 != null) {
							conn_iPostgresqlDbUpdate_1.rollback();
							conn_iPostgresqlDbUpdate_1.close();
						}
						System.out
								.println("***** completed finally block ***********");
					}

				} finally {
					System.out.println("In finally block");
					if (tempFile_iPostgresqlDbUpdate_1 != null)
						tempFile_iPostgresqlDbUpdate_1.delete();
					if (tempDir_iPostgresqlDbUpdate_1 != null)
						tempDir_iPostgresqlDbUpdate_1.delete();
					if (out_iPostgresqlDbUpdate_1 != null)
						out_iPostgresqlDbUpdate_1.close();
				}

				/**
				 * [iPostgresqlDbUpdate_1 begin ] stop
				 */
				/**
				 * [iPostgresqlDbUpdate_1 main ] start
				 */

				currentComponent = "iPostgresqlDbUpdate_1";

				tos_count_iPostgresqlDbUpdate_1++;

				/**
				 * [iPostgresqlDbUpdate_1 main ] stop
				 */
				/**
				 * [iPostgresqlDbUpdate_1 end ] start
				 */

				currentComponent = "iPostgresqlDbUpdate_1";

				ok_Hash.put("iPostgresqlDbUpdate_1", true);
				end_Hash.put("iPostgresqlDbUpdate_1", System
						.currentTimeMillis());

				/**
				 * [iPostgresqlDbUpdate_1 end ] stop
				 */

			}// end the resume

			if (resumeEntryMethodName == null || globalResumeTicket) {
				resumeUtil
						.addLog(
								"CHECKPOINT",
								"CONNECTION:SUBJOB_OK:iPostgresqlDbUpdate_1:OnSubjobOk",
								"", Thread.currentThread().getId() + "", "",
								"", "", "", "");
			}

			iIndexFiles_2_iFilesProcess(globalMap);

		} catch (java.lang.Exception e) {

			throw new TalendException(e, currentComponent, globalMap);

		} catch (java.lang.Error error) {

			throw new java.lang.Error(error);

		}

		globalMap.put("iPostgresqlDbUpdate_1_SUBPROCESS_STATE", 1);
	}

	public void iHarvestResources_1Process(
			final java.util.Map<String, Object> globalMap)
			throws TalendException {
		globalMap.put("iHarvestResources_1_SUBPROCESS_STATE", 0);

		final boolean execStat = this.execStat;

		String iterateId = "";
		String currentComponent = "";

		try {

			String currentMethodName = new java.lang.Exception()
					.getStackTrace()[0].getMethodName();
			boolean resumeIt = currentMethodName.equals(resumeEntryMethodName);
			if (resumeEntryMethodName == null || resumeIt || globalResumeTicket) {// start
																					// the
																					// resume
				globalResumeTicket = true;

				/**
				 * [iHarvestResources_1 begin ] start
				 */

				int NB_ITERATE_tRunJob_1 = 0; // for statistics

				ok_Hash.put("iHarvestResources_1", false);
				start_Hash.put("iHarvestResources_1", System
						.currentTimeMillis());
				currentComponent = "iHarvestResources_1";

				int tos_count_iHarvestResources_1 = 0;

				String dbquery_iHarvestResources_1 = "select indexed_file.id, indexed_file.url, indexed_file.modified "
						+ "  from indexed_file "
						+ "  join index_job "
						+ "    on indexed_file.job_id = index_job.id "
						+ "   and indexed_file.last_indexed_run = index_job.last_run_no "
						+ "   and index_job.name = ? "
						+ "  left join file_harvest "
						+ "    on file_harvest.file_id = indexed_file.id "
						+ "   and file_harvest.harvest_type = ? "
						+ " where (file_harvest.last_moddate_harvested <> indexed_file.modified "
						+ "    or  file_harvest.last_moddate_harvested is null) ";

				int nb_resources_iHarvestResources_1 = 0;

				String url_iHarvestResources_1 = "jdbc:postgresql://"
						+ context.metadataDb_RT_Server + ":"
						+ context.metadataDb_RT_Port + "/"
						+ context.metadataDb_RT_Database;
				String schema_iHarvestResources_1 = context.metadataDb_RT_Schema;
				String userName_iHarvestResources_1 = context.metadataDb_RT_Login;
				String password_iHarvestResources_1 = context.metadataDb_RT_Password;
				String jobName_iHarvestResources_1 = "index";
				String harvestType_iHarvestResources_1 = "harvest";

				java.sql.Connection conn_iHarvestResources_1 = null;

				try {
					// Get connection
					java.lang.Class.forName("org.postgresql.Driver");
					conn_iHarvestResources_1 = java.sql.DriverManager
							.getConnection(url_iHarvestResources_1,
									userName_iHarvestResources_1,
									password_iHarvestResources_1);
					conn_iHarvestResources_1.setAutoCommit(false);

					// Determine resources that have been added or modified
					// since last invocation

					java.sql.PreparedStatement resourcesStmtiHarvestResources_1 = conn_iHarvestResources_1
							.prepareStatement(dbquery_iHarvestResources_1);

					resourcesStmtiHarvestResources_1.setString(1,
							jobName_iHarvestResources_1);
					resourcesStmtiHarvestResources_1.setString(2,
							harvestType_iHarvestResources_1);

					java.sql.ResultSet resourcesRS_iHarvestResources_1 = resourcesStmtiHarvestResources_1
							.executeQuery();

					while (resourcesRS_iHarvestResources_1.next()) {

						Long id_iHarvestResources_1 = resourcesRS_iHarvestResources_1
								.getLong("id");
						String resourceUrl_iHarvestResources_1 = resourcesRS_iHarvestResources_1
								.getString("url");
						java.util.Date lastModified_iHarvestResources_1 = new java.util.Date(
								resourcesRS_iHarvestResources_1.getTimestamp(
										"modified").getTime());

						globalMap.put("iHarvestResources_1_FILE_ID",
								id_iHarvestResources_1);
						globalMap.put("iHarvestResources_1_URL",
								resourceUrl_iHarvestResources_1);
						globalMap.put("iHarvestResources_1_MODIFIED",
								lastModified_iHarvestResources_1);

						try {

							// Iterate

							/**
							 * [iHarvestResources_1 begin ] stop
							 */
							/**
							 * [iHarvestResources_1 main ] start
							 */

							currentComponent = "iHarvestResources_1";

							tos_count_iHarvestResources_1++;

							/**
							 * [iHarvestResources_1 main ] stop
							 */
							NB_ITERATE_tRunJob_1++;

							/**
							 * [tRunJob_1 begin ] start
							 */

							ok_Hash.put("tRunJob_1", false);
							start_Hash.put("tRunJob_1", System
									.currentTimeMillis());
							currentComponent = "tRunJob_1";

							int tos_count_tRunJob_1 = 0;

							/**
							 * [tRunJob_1 begin ] stop
							 */
							/**
							 * [tRunJob_1 main ] start
							 */

							currentComponent = "tRunJob_1";

							java.util.List<String> paraList_tRunJob_1 = new java.util.ArrayList<String>();
							paraList_tRunJob_1.add("--father_pid=" + pid);

							paraList_tRunJob_1.add("--root_pid=" + rootPid);

							paraList_tRunJob_1.add("--father_node=tRunJob_1");

							paraList_tRunJob_1.add("--context=Default");

							// for feature:10589
							paraList_tRunJob_1.add("--stat_port=" + portStats);

							if (resuming_logs_dir_path != null) {
								paraList_tRunJob_1
										.add("--resuming_logs_dir_path="
												+ resuming_logs_dir_path);
							}
							String childResumePath_tRunJob_1 = ResumeUtil
									.getChildJobCheckPointPath(resuming_checkpoint_path);
							String tRunJobName_tRunJob_1 = ResumeUtil
									.getRighttRunJob(resuming_checkpoint_path);
							if ("tRunJob_1".equals(tRunJobName_tRunJob_1)
									&& childResumePath_tRunJob_1 != null) {
								paraList_tRunJob_1
										.add("--resuming_checkpoint_path="
												+ ResumeUtil
														.getChildJobCheckPointPath(resuming_checkpoint_path));
							}
							paraList_tRunJob_1
									.add("--parent_part_launcher=JOB:"
											+ jobName + "/NODE:tRunJob_1");

							java.util.Map<String, Object> parentContextMap_tRunJob_1 = new java.util.HashMap<String, Object>();

							context.synchronizeContext();
							java.util.Enumeration<?> propertyNames_tRunJob_1 = context
									.propertyNames();
							while (propertyNames_tRunJob_1.hasMoreElements()) {
								String key_tRunJob_1 = (String) propertyNames_tRunJob_1
										.nextElement();
								Object value_tRunJob_1 = (Object) context
										.get(key_tRunJob_1);
								paraList_tRunJob_1
										.add("--context_param " + key_tRunJob_1
												+ "=" + value_tRunJob_1);
							}

							parentContextMap_tRunJob_1.put("logDir",
									context.logDir);
							parentContextMap_tRunJob_1.put("paramFile",
									context.paramFile);
							parentContextMap_tRunJob_1.put(
									"metadataDb_RT_Database",
									context.metadataDb_RT_Database);
							parentContextMap_tRunJob_1.put(
									"metadataDb_RT_Login",
									context.metadataDb_RT_Login);
							parentContextMap_tRunJob_1.put(
									"metadataDb_RT_Password",
									context.metadataDb_RT_Password);
							parentContextMap_tRunJob_1.put(
									"metadataDb_RT_Port",
									context.metadataDb_RT_Port);
							parentContextMap_tRunJob_1.put(
									"metadataDb_RT_Schema",
									context.metadataDb_RT_Schema);
							parentContextMap_tRunJob_1.put(
									"metadataDb_RT_Server",
									context.metadataDb_RT_Server);
							parentContextMap_tRunJob_1.put("exclude",
									context.exclude);
							parentContextMap_tRunJob_1.put("fileId",
									context.fileId);
							parentContextMap_tRunJob_1.put("include",
									context.include);
							parentContextMap_tRunJob_1.put("sourceDir",
									context.sourceDir);
							parentContextMap_tRunJob_1.put("url", context.url);

							Object obj_tRunJob_1 = null;

							obj_tRunJob_1 = ((String) globalMap
									.get("iHarvestResources_1_URL"));
							paraList_tRunJob_1
									.add("--context_param url="
											+ RuntimeUtils
													.tRunJobConvertContext(obj_tRunJob_1));
							parentContextMap_tRunJob_1
									.put("url", obj_tRunJob_1);
							obj_tRunJob_1 = ((Long) globalMap
									.get("iHarvestResources_1_FILE_ID"));
							paraList_tRunJob_1
									.add("--context_param fileId="
											+ RuntimeUtils
													.tRunJobConvertContext(obj_tRunJob_1));
							parentContextMap_tRunJob_1.put("fileId",
									obj_tRunJob_1);
							anfog_dm.harvestfilesystemmetadata_rt_0_1.HarvestFileSystemMetadata_RT childJob_tRunJob_1 = new anfog_dm.harvestfilesystemmetadata_rt_0_1.HarvestFileSystemMetadata_RT();
							childJob_tRunJob_1.parentContextMap = parentContextMap_tRunJob_1;
							String[][] childReturn_tRunJob_1 = childJob_tRunJob_1
									.runJob((String[]) paraList_tRunJob_1
											.toArray(new String[paraList_tRunJob_1
													.size()]));
							errorCode = childJob_tRunJob_1.getErrorCode();

							if (childJob_tRunJob_1.getErrorCode() == null) {
								globalMap
										.put(
												"tRunJob_1_CHILD_RETURN_CODE",
												childJob_tRunJob_1.getStatus() != null
														&& ("failure")
																.equals(childJob_tRunJob_1
																		.getStatus()) ? 1
														: 0);
							} else {
								globalMap.put("tRunJob_1_CHILD_RETURN_CODE",
										childJob_tRunJob_1.getErrorCode());
							}
							globalMap
									.put(
											"tRunJob_1_CHILD_EXCEPTION_STACKTRACE",
											childJob_tRunJob_1
													.getExceptionStackTrace());

							if (childJob_tRunJob_1.getErrorCode() != null
									|| ("failure").equals(childJob_tRunJob_1
											.getStatus())) {
								throw new RuntimeException(
										"Child job running failed");
							}

							tos_count_tRunJob_1++;

							/**
							 * [tRunJob_1 main ] stop
							 */
							/**
							 * [tRunJob_1 end ] start
							 */

							currentComponent = "tRunJob_1";

							ok_Hash.put("tRunJob_1", true);
							end_Hash.put("tRunJob_1", System
									.currentTimeMillis());

							/**
							 * [tRunJob_1 end ] stop
							 */

							/**
							 * [iHarvestResources_1 end ] start
							 */

							currentComponent = "iHarvestResources_1";

							// Determine if an existing harvest record for this
							// file exists

							java.sql.Statement stmt_iHarvestResources_1 = conn_iHarvestResources_1
									.createStatement();

							String fileHarvestCountQuery_iHarvestResources_1 = "select count(1) from file_harvest "
									+ " WHERE harvest_type = '"
									+ harvestType_iHarvestResources_1
									+ "' "
									+ "   AND file_id = "
									+ Long.toString(id_iHarvestResources_1);

							java.sql.ResultSet rs_iHarvestResources_1 = stmt_iHarvestResources_1
									.executeQuery(fileHarvestCountQuery_iHarvestResources_1);

							java.sql.PreparedStatement pstmt_iHarvestResources_1;

							// If a record exists, update it otherwise create
							// one

							if (rs_iHarvestResources_1.next()
									&& rs_iHarvestResources_1.getInt(1) > 0) {
								// Update the record to record the new last
								// modified date that has been processed
								String update_iHarvestResources_1 = "update file_harvest "
										+ " set last_moddate_harvested = ? WHERE harvest_type = ? AND file_id = ?";

								pstmt_iHarvestResources_1 = conn_iHarvestResources_1
										.prepareStatement(update_iHarvestResources_1);

								pstmt_iHarvestResources_1.setTimestamp(1,
										new java.sql.Timestamp(
												lastModified_iHarvestResources_1
														.getTime()));
								pstmt_iHarvestResources_1.setString(2,
										harvestType_iHarvestResources_1);
								pstmt_iHarvestResources_1.setLong(3,
										id_iHarvestResources_1);
							} else {
								// Insert a record with for the file recording
								// the last modified date harvested
								String insert_iHarvestResources_1 = "insert into file_harvest "
										+ " (harvest_type, file_id, last_moddate_harvested) VALUES (?,?,?)";

								pstmt_iHarvestResources_1 = conn_iHarvestResources_1
										.prepareStatement(insert_iHarvestResources_1);

								pstmt_iHarvestResources_1.setString(1,
										harvestType_iHarvestResources_1);
								pstmt_iHarvestResources_1.setLong(2,
										id_iHarvestResources_1);
								pstmt_iHarvestResources_1.setTimestamp(3,
										new java.sql.Timestamp(
												lastModified_iHarvestResources_1
														.getTime()));
							}

							pstmt_iHarvestResources_1.executeUpdate();

							// file has been successfully processed so commit
							// changes
							conn_iHarvestResources_1.commit();

							nb_resources_iHarvestResources_1++;

							// Catch any exceptions processing a resource and
							// continue with next
							// TODO: add other options e.g. die on exception,
							// die after x number of failures etc
						} catch (RuntimeException r) {
							// Handle exceptions thrown in child jobs (rethrown
							// as runtime exceptions)
							if (r.getMessage().equals(
									"Child job running failed")) {
								// Log error and continue wih next resource
								System.err
										.println("Exception in child job while processing "
												+ resourceUrl_iHarvestResources_1);
								r.printStackTrace();
							} else {
								throw r;
							}
						} catch (Exception e) {
							// Log error and continue wih next resource
							System.err.println("Exception while processing "
									+ resourceUrl_iHarvestResources_1);
							e.printStackTrace();
						}
					}
				} finally {
					if (conn_iHarvestResources_1 != null) {
						conn_iHarvestResources_1.rollback();
						conn_iHarvestResources_1.close();
						conn_iHarvestResources_1 = null;
					}
				}

				globalMap.put("iHarvestResources_1_NB_RESOURCES",
						nb_resources_iHarvestResources_1);

				ok_Hash.put("iHarvestResources_1", true);
				end_Hash.put("iHarvestResources_1", System.currentTimeMillis());

				/**
				 * [iHarvestResources_1 end ] stop
				 */

			}// end the resume

			if (resumeEntryMethodName == null || globalResumeTicket) {
				resumeUtil.addLog("CHECKPOINT",
						"CONNECTION:SUBJOB_OK:iHarvestResources_1:OnSubjobOk",
						"", Thread.currentThread().getId() + "", "", "", "",
						"", "");
			}

			iDeletedResources_1Process(globalMap);

		} catch (java.lang.Exception e) {

			throw new TalendException(e, currentComponent, globalMap);

		} catch (java.lang.Error error) {

			throw new java.lang.Error(error);

		}

		globalMap.put("iHarvestResources_1_SUBPROCESS_STATE", 1);
	}

	public void iDeletedResources_1Process(
			final java.util.Map<String, Object> globalMap)
			throws TalendException {
		globalMap.put("iDeletedResources_1_SUBPROCESS_STATE", 0);

		final boolean execStat = this.execStat;

		String iterateId = "";
		String currentComponent = "";

		try {

			String currentMethodName = new java.lang.Exception()
					.getStackTrace()[0].getMethodName();
			boolean resumeIt = currentMethodName.equals(resumeEntryMethodName);
			if (resumeEntryMethodName == null || resumeIt || globalResumeTicket) {// start
																					// the
																					// resume
				globalResumeTicket = true;

				/**
				 * [iDeletedResources_1 begin ] start
				 */

				int NB_ITERATE_tRunJob_2 = 0; // for statistics

				ok_Hash.put("iDeletedResources_1", false);
				start_Hash.put("iDeletedResources_1", System
						.currentTimeMillis());
				currentComponent = "iDeletedResources_1";

				int tos_count_iDeletedResources_1 = 0;

				String dbquery_iDeletedResources_1 = "select id, url, modified "
						+ "  from deleted_resource "
						+ " where job_name = ? "
						+ "   and harvest_type = ? ";

				int nb_resources_iDeletedResources_1 = 0;

				String url_iDeletedResources_1 = "jdbc:postgresql://"
						+ context.metadataDb_RT_Server + ":"
						+ context.metadataDb_RT_Port + "/"
						+ context.metadataDb_RT_Database;
				String schema_iDeletedResources_1 = context.metadataDb_RT_Schema;
				String userName_iDeletedResources_1 = context.metadataDb_RT_Login;
				String password_iDeletedResources_1 = context.metadataDb_RT_Password;
				String jobName_iDeletedResources_1 = "index";
				String harvestType_iDeletedResources_1 = "harvest";

				java.sql.Connection conn_iDeletedResources_1 = null;

				try {
					// Get connection
					java.lang.Class.forName("org.postgresql.Driver");
					conn_iDeletedResources_1 = java.sql.DriverManager
							.getConnection(url_iDeletedResources_1,
									userName_iDeletedResources_1,
									password_iDeletedResources_1);
					conn_iDeletedResources_1.setAutoCommit(false);

					// Determine resources that have been added or modified
					// since last invocation

					java.sql.PreparedStatement resourcesStmtiDeletedResources_1 = conn_iDeletedResources_1
							.prepareStatement(dbquery_iDeletedResources_1);

					resourcesStmtiDeletedResources_1.setString(1,
							jobName_iDeletedResources_1);
					resourcesStmtiDeletedResources_1.setString(2,
							harvestType_iDeletedResources_1);

					java.sql.ResultSet resourcesRS_iDeletedResources_1 = resourcesStmtiDeletedResources_1
							.executeQuery();

					while (resourcesRS_iDeletedResources_1.next()) {

						Long id_iDeletedResources_1 = resourcesRS_iDeletedResources_1
								.getLong("id");
						String resourceUrl_iDeletedResources_1 = resourcesRS_iDeletedResources_1
								.getString("url");
						java.util.Date lastModified_iDeletedResources_1 = new java.util.Date(
								resourcesRS_iDeletedResources_1.getTimestamp(
										"modified").getTime());

						globalMap.put("iDeletedResources_1_FILE_ID",
								id_iDeletedResources_1);
						globalMap.put("iDeletedResources_1_URL",
								resourceUrl_iDeletedResources_1);
						globalMap.put("iDeletedResources_1_MODIFIED",
								lastModified_iDeletedResources_1);

						try {

							// Iterate

							/**
							 * [iDeletedResources_1 begin ] stop
							 */
							/**
							 * [iDeletedResources_1 main ] start
							 */

							currentComponent = "iDeletedResources_1";

							tos_count_iDeletedResources_1++;

							/**
							 * [iDeletedResources_1 main ] stop
							 */
							NB_ITERATE_tRunJob_2++;

							/**
							 * [tRunJob_2 begin ] start
							 */

							ok_Hash.put("tRunJob_2", false);
							start_Hash.put("tRunJob_2", System
									.currentTimeMillis());
							currentComponent = "tRunJob_2";

							int tos_count_tRunJob_2 = 0;

							/**
							 * [tRunJob_2 begin ] stop
							 */
							/**
							 * [tRunJob_2 main ] start
							 */

							currentComponent = "tRunJob_2";

							java.util.List<String> paraList_tRunJob_2 = new java.util.ArrayList<String>();
							paraList_tRunJob_2.add("--father_pid=" + pid);

							paraList_tRunJob_2.add("--root_pid=" + rootPid);

							paraList_tRunJob_2.add("--father_node=tRunJob_2");

							paraList_tRunJob_2.add("--context=Default");

							// for feature:10589
							paraList_tRunJob_2.add("--stat_port=" + portStats);

							if (resuming_logs_dir_path != null) {
								paraList_tRunJob_2
										.add("--resuming_logs_dir_path="
												+ resuming_logs_dir_path);
							}
							String childResumePath_tRunJob_2 = ResumeUtil
									.getChildJobCheckPointPath(resuming_checkpoint_path);
							String tRunJobName_tRunJob_2 = ResumeUtil
									.getRighttRunJob(resuming_checkpoint_path);
							if ("tRunJob_2".equals(tRunJobName_tRunJob_2)
									&& childResumePath_tRunJob_2 != null) {
								paraList_tRunJob_2
										.add("--resuming_checkpoint_path="
												+ ResumeUtil
														.getChildJobCheckPointPath(resuming_checkpoint_path));
							}
							paraList_tRunJob_2
									.add("--parent_part_launcher=JOB:"
											+ jobName + "/NODE:tRunJob_2");

							java.util.Map<String, Object> parentContextMap_tRunJob_2 = new java.util.HashMap<String, Object>();

							context.synchronizeContext();
							java.util.Enumeration<?> propertyNames_tRunJob_2 = context
									.propertyNames();
							while (propertyNames_tRunJob_2.hasMoreElements()) {
								String key_tRunJob_2 = (String) propertyNames_tRunJob_2
										.nextElement();
								Object value_tRunJob_2 = (Object) context
										.get(key_tRunJob_2);
								paraList_tRunJob_2
										.add("--context_param " + key_tRunJob_2
												+ "=" + value_tRunJob_2);
							}

							parentContextMap_tRunJob_2.put("logDir",
									context.logDir);
							parentContextMap_tRunJob_2.put("paramFile",
									context.paramFile);
							parentContextMap_tRunJob_2.put(
									"metadataDb_RT_Database",
									context.metadataDb_RT_Database);
							parentContextMap_tRunJob_2.put(
									"metadataDb_RT_Login",
									context.metadataDb_RT_Login);
							parentContextMap_tRunJob_2.put(
									"metadataDb_RT_Password",
									context.metadataDb_RT_Password);
							parentContextMap_tRunJob_2.put(
									"metadataDb_RT_Port",
									context.metadataDb_RT_Port);
							parentContextMap_tRunJob_2.put(
									"metadataDb_RT_Schema",
									context.metadataDb_RT_Schema);
							parentContextMap_tRunJob_2.put(
									"metadataDb_RT_Server",
									context.metadataDb_RT_Server);
							parentContextMap_tRunJob_2.put("exclude",
									context.exclude);
							parentContextMap_tRunJob_2.put("fileId",
									context.fileId);
							parentContextMap_tRunJob_2.put("include",
									context.include);
							parentContextMap_tRunJob_2.put("sourceDir",
									context.sourceDir);
							parentContextMap_tRunJob_2.put("url", context.url);

							Object obj_tRunJob_2 = null;

							obj_tRunJob_2 = ((Long) globalMap
									.get("iHarvestResources_1_FILE_ID"));
							paraList_tRunJob_2
									.add("--context_param fileId="
											+ RuntimeUtils
													.tRunJobConvertContext(obj_tRunJob_2));
							parentContextMap_tRunJob_2.put("fileId",
									obj_tRunJob_2);
							anfog_dm.deletemetadata_rt_0_1.DeleteMetadata_RT childJob_tRunJob_2 = new anfog_dm.deletemetadata_rt_0_1.DeleteMetadata_RT();
							childJob_tRunJob_2.parentContextMap = parentContextMap_tRunJob_2;
							String[][] childReturn_tRunJob_2 = childJob_tRunJob_2
									.runJob((String[]) paraList_tRunJob_2
											.toArray(new String[paraList_tRunJob_2
													.size()]));
							errorCode = childJob_tRunJob_2.getErrorCode();

							if (childJob_tRunJob_2.getErrorCode() == null) {
								globalMap
										.put(
												"tRunJob_2_CHILD_RETURN_CODE",
												childJob_tRunJob_2.getStatus() != null
														&& ("failure")
																.equals(childJob_tRunJob_2
																		.getStatus()) ? 1
														: 0);
							} else {
								globalMap.put("tRunJob_2_CHILD_RETURN_CODE",
										childJob_tRunJob_2.getErrorCode());
							}
							globalMap
									.put(
											"tRunJob_2_CHILD_EXCEPTION_STACKTRACE",
											childJob_tRunJob_2
													.getExceptionStackTrace());

							if (childJob_tRunJob_2.getErrorCode() != null
									|| ("failure").equals(childJob_tRunJob_2
											.getStatus())) {
								throw new RuntimeException(
										"Child job running failed");
							}

							tos_count_tRunJob_2++;

							/**
							 * [tRunJob_2 main ] stop
							 */
							/**
							 * [tRunJob_2 end ] start
							 */

							currentComponent = "tRunJob_2";

							ok_Hash.put("tRunJob_2", true);
							end_Hash.put("tRunJob_2", System
									.currentTimeMillis());

							/**
							 * [tRunJob_2 end ] stop
							 */

							/**
							 * [iDeletedResources_1 end ] start
							 */

							currentComponent = "iDeletedResources_1";

							// Delete form harvested files

							String delete_iDeletedResources_1 = "delete from file_harvest "
									+ "WHERE harvest_type = ? AND file_id = ?";

							java.sql.PreparedStatement pstmt_iDeletedResources_1 = conn_iDeletedResources_1
									.prepareStatement(delete_iDeletedResources_1);

							pstmt_iDeletedResources_1.setString(1,
									harvestType_iDeletedResources_1);
							pstmt_iDeletedResources_1.setLong(2,
									id_iDeletedResources_1);

							pstmt_iDeletedResources_1.executeUpdate();

							// file has been successfully processed so commit
							// changes
							conn_iDeletedResources_1.commit();

							nb_resources_iDeletedResources_1++;

							// Catch any exceptions processing a resource and
							// continue with next
							// TODO: add other options e.g. die on exception,
							// die after x number of failures etc
						} catch (RuntimeException r) {
							// Handle exceptions thrown in child jobs (rethrown
							// as runtime exceptions)
							if (r.getMessage().equals(
									"Child job running failed")) {
								// Log error and continue wih next resource
								System.err
										.println("Exception in child job while processing "
												+ resourceUrl_iDeletedResources_1);
								r.printStackTrace();
							} else {
								throw r;
							}
						} catch (Exception e) {
							// Log error and continue wih next resource
							System.err.println("Exception while processing "
									+ resourceUrl_iDeletedResources_1);
							e.printStackTrace();
						}
					}
				} finally {
					if (conn_iDeletedResources_1 != null) {
						conn_iDeletedResources_1.rollback();
						conn_iDeletedResources_1.close();
						conn_iDeletedResources_1 = null;
					}
				}

				globalMap.put("iDeletedResources_1_NB_RESOURCES",
						nb_resources_iDeletedResources_1);

				ok_Hash.put("iDeletedResources_1", true);
				end_Hash.put("iDeletedResources_1", System.currentTimeMillis());

				/**
				 * [iDeletedResources_1 end ] stop
				 */

			}// end the resume

		} catch (java.lang.Exception e) {

			throw new TalendException(e, currentComponent, globalMap);

		} catch (java.lang.Error error) {

			throw new java.lang.Error(error);

		}

		globalMap.put("iDeletedResources_1_SUBPROCESS_STATE", 1);
	}

	public static class row_iIndexFiles_2_iFilesStruct implements
			routines.system.IPersistableRow<row_iIndexFiles_2_iFilesStruct> {
		final static byte[] commonByteArrayLock_ANFOG_DM_HarvestMetadataFileSystem_RT = new byte[0];
		static byte[] commonByteArray_ANFOG_DM_HarvestMetadataFileSystem_RT = new byte[0];

		public String filePath;

		public String getFilePath() {
			return this.filePath;
		}

		public java.util.Date fileLastModified;

		public java.util.Date getFileLastModified() {
			return this.fileLastModified;
		}

		public Double fileSize;

		public Double getFileSize() {
			return this.fileSize;
		}

		private String readString(ObjectInputStream dis) throws IOException {
			String strReturn = null;
			int length = 0;
			length = dis.readInt();
			if (length == -1) {
				strReturn = null;
			} else {
				if (length > commonByteArray_ANFOG_DM_HarvestMetadataFileSystem_RT.length) {
					if (length < 1024
							&& commonByteArray_ANFOG_DM_HarvestMetadataFileSystem_RT.length == 0) {
						commonByteArray_ANFOG_DM_HarvestMetadataFileSystem_RT = new byte[1024];
					} else {
						commonByteArray_ANFOG_DM_HarvestMetadataFileSystem_RT = new byte[2 * length];
					}
				}
				dis.readFully(
						commonByteArray_ANFOG_DM_HarvestMetadataFileSystem_RT,
						0, length);
				strReturn = new String(
						commonByteArray_ANFOG_DM_HarvestMetadataFileSystem_RT,
						0, length, utf8Charset);
			}
			return strReturn;
		}

		private void writeString(String str, ObjectOutputStream dos)
				throws IOException {
			if (str == null) {
				dos.writeInt(-1);
			} else {
				byte[] byteArray = str.getBytes(utf8Charset);
				dos.writeInt(byteArray.length);
				dos.write(byteArray);
			}
		}

		private java.util.Date readDate(ObjectInputStream dis)
				throws IOException {
			java.util.Date dateReturn = null;
			int length = 0;
			length = dis.readByte();
			if (length == -1) {
				dateReturn = null;
			} else {
				dateReturn = new Date(dis.readLong());
			}
			return dateReturn;
		}

		private void writeDate(java.util.Date date1, ObjectOutputStream dos)
				throws IOException {
			if (date1 == null) {
				dos.writeByte(-1);
			} else {
				dos.writeByte(0);
				dos.writeLong(date1.getTime());
			}
		}

		public void readData(ObjectInputStream dis) {

			synchronized (commonByteArrayLock_ANFOG_DM_HarvestMetadataFileSystem_RT) {

				try {

					int length = 0;

					this.filePath = readString(dis);

					this.fileLastModified = readDate(dis);

					length = dis.readByte();
					if (length == -1) {
						this.fileSize = null;
					} else {
						this.fileSize = dis.readDouble();
					}

				} catch (IOException e) {
					throw new RuntimeException(e);

				}

			}

		}

		public void writeData(ObjectOutputStream dos) {
			try {

				// String

				writeString(this.filePath, dos);

				// java.util.Date

				writeDate(this.fileLastModified, dos);

				// Double

				if (this.fileSize == null) {
					dos.writeByte(-1);
				} else {
					dos.writeByte(0);
					dos.writeDouble(this.fileSize);
				}

			} catch (IOException e) {
				throw new RuntimeException(e);
			}

		}

		public String toString() {

			StringBuilder sb = new StringBuilder();
			sb.append(super.toString());
			sb.append("[");
			sb.append("filePath=" + filePath);
			sb.append(",fileLastModified=" + String.valueOf(fileLastModified));
			sb.append(",fileSize=" + String.valueOf(fileSize));
			sb.append("]");

			return sb.toString();
		}

		/**
		 * Compare keys
		 */
		public int compareTo(row_iIndexFiles_2_iFilesStruct other) {

			int returnValue = -1;

			return returnValue;
		}

		private int checkNullsAndCompare(Object object1, Object object2) {
			int returnValue = 0;
			if (object1 instanceof Comparable && object2 instanceof Comparable) {
				returnValue = ((Comparable) object1).compareTo(object2);
			} else if (object1 != null && object2 != null) {
				returnValue = compareStrings(object1.toString(), object2
						.toString());
			} else if (object1 == null && object2 != null) {
				returnValue = 1;
			} else if (object1 != null && object2 == null) {
				returnValue = -1;
			} else {
				returnValue = 0;
			}

			return returnValue;
		}

		private int compareStrings(String string1, String string2) {
			return string1.compareTo(string2);
		}

	}

	public void iIndexFiles_2_iFilesProcess(
			final java.util.Map<String, Object> globalMap)
			throws TalendException {
		globalMap.put("iIndexFiles_2_iFiles_SUBPROCESS_STATE", 0);

		final boolean execStat = this.execStat;

		String iterateId = "";
		String currentComponent = "";

		try {

			String currentMethodName = new java.lang.Exception()
					.getStackTrace()[0].getMethodName();
			boolean resumeIt = currentMethodName.equals(resumeEntryMethodName);
			if (resumeEntryMethodName == null || resumeIt || globalResumeTicket) {// start
																					// the
																					// resume
				globalResumeTicket = true;

				row_iIndexFiles_2_iFilesStruct row_iIndexFiles_2_iFiles = new row_iIndexFiles_2_iFilesStruct();

				/**
				 * [iIndexFiles_2_iIndexer begin ] start
				 */

				ok_Hash.put("iIndexFiles_2_iIndexer", false);
				start_Hash.put("iIndexFiles_2_iIndexer", System
						.currentTimeMillis());
				currentComponent = "iIndexFiles_2_iIndexer";

				int tos_count_iIndexFiles_2_iIndexer = 0;

				int nb_line_iIndexFiles_2_iIndexer = 0;

				String url_iIndexFiles_2_iIndexer = "jdbc:postgresql://"
						+ context.metadataDb_RT_Server + ":"
						+ context.metadataDb_RT_Port + "/"
						+ context.metadataDb_RT_Database;
				String schema_iIndexFiles_2_iIndexer = context.metadataDb_RT_Schema;
				String userName_iIndexFiles_2_iIndexer = context.metadataDb_RT_Login;
				String password_iIndexFiles_2_iIndexer = context.metadataDb_RT_Password;
				String jobName_iIndexFiles_2_iIndexer = "index";

				java.sql.Connection conn_iIndexFiles_2_iIndexer = null;

				long runNo_iIndexFiles_2_iIndexer = -1L;
				long jobId_iIndexFiles_2_iIndexer = -1L;

				try {
					// Connect to indexing database

					java.lang.Class.forName("org.postgresql.Driver");
					conn_iIndexFiles_2_iIndexer = java.sql.DriverManager
							.getConnection(url_iIndexFiles_2_iIndexer,
									userName_iIndexFiles_2_iIndexer,
									password_iIndexFiles_2_iIndexer);
					conn_iIndexFiles_2_iIndexer.setAutoCommit(false);

					// Run liquibase changelog to create or update indexing
					// tables

					liquibase.database.Database database = liquibase.database.DatabaseFactory
							.getInstance().findCorrectDatabaseImplementation(
									new liquibase.database.jvm.JdbcConnection(
											conn_iIndexFiles_2_iIndexer));
					database.setDefaultSchemaName(schema_iIndexFiles_2_iIndexer);
					liquibase.Liquibase liquibase = new liquibase.Liquibase(
							"iPostgresqlIndexResources_changelog.xml",
							new liquibase.resource.ClassLoaderResourceAccessor(),
							database);
					liquibase.update(null);

					// Try getting the run number by adding 1 to the last run
					// number for this job

					String updateStmt = "UPDATE index_job "
							+ " SET last_run_no = last_run_no + 1, last_run_date = ? WHERE name = ?";

					java.sql.PreparedStatement pstmtUpdate = conn_iIndexFiles_2_iIndexer
							.prepareStatement(updateStmt);
					pstmtUpdate.setTimestamp(1, new java.sql.Timestamp(
							(new Date()).getTime()));
					pstmtUpdate.setString(2, jobName_iIndexFiles_2_iIndexer);
					int updateFlag = pstmtUpdate.executeUpdate();

					// If there was no last run number for this job create a new
					// record setting the run number to 1

					if (updateFlag == 0) {
						String insertStmt = "INSERT INTO index_job "
								+ " (name, last_run_no, last_run_date) VALUES (?,?,?)";
						java.sql.PreparedStatement pstmtInsert = conn_iIndexFiles_2_iIndexer
								.prepareStatement(insertStmt);
						pstmtInsert
								.setString(1, jobName_iIndexFiles_2_iIndexer);
						pstmtInsert.setLong(2, 1);
						pstmtInsert.setTimestamp(3, new java.sql.Timestamp(
								(new Date()).getTime()));
						pstmtInsert.executeUpdate();
					}

					conn_iIndexFiles_2_iIndexer.commit();

					// Get job id and run number to be used for this run (just
					// recorded above)

					java.sql.Statement stmt = conn_iIndexFiles_2_iIndexer
							.createStatement();
					String dbquery = "select id, last_run_no from index_job where name = '"
							+ jobName_iIndexFiles_2_iIndexer + "'";
					java.sql.ResultSet rs = stmt.executeQuery(dbquery);
					rs.next();
					jobId_iIndexFiles_2_iIndexer = rs.getLong("id");
					runNo_iIndexFiles_2_iIndexer = rs.getLong("last_run_no");

				} finally {
					if (conn_iIndexFiles_2_iIndexer != null) {
						conn_iIndexFiles_2_iIndexer.rollback();
						conn_iIndexFiles_2_iIndexer.close();
						conn_iIndexFiles_2_iIndexer = null;
					}
				}

				try {
					// create postgresql connection
					java.lang.Class.forName("org.postgresql.Driver");
					conn_iIndexFiles_2_iIndexer = java.sql.DriverManager
							.getConnection(url_iIndexFiles_2_iIndexer,
									userName_iIndexFiles_2_iIndexer,
									password_iIndexFiles_2_iIndexer);
					conn_iIndexFiles_2_iIndexer.setAutoCommit(false);

					// commit management
					int commitEvery_iIndexFiles_2_iIndexer = 10000;
					int commitCounter_iIndexFiles_2_iIndexer = 0;

					// prepared statments used to create or update indexed
					// resource details

					String update_iIndexFiles_2_iIndexer = "UPDATE indexed_file "
							+ "  SET modified = ?, size = ?, last_indexed = ?, last_indexed_run = ? "
							+ "WHERE job_id = ? AND url = ?";

					java.sql.PreparedStatement pstmtUpdate_iIndexFiles_2_iIndexer = conn_iIndexFiles_2_iIndexer
							.prepareStatement(update_iIndexFiles_2_iIndexer);

					String insert_iIndexFiles_2_iIndexer = "INSERT INTO indexed_file "
							+ "(job_id, url, modified, size, last_indexed, last_indexed_run) "
							+ "VALUES (?,?,?,?,?,?)";

					java.sql.PreparedStatement pstmtInsert_iIndexFiles_2_iIndexer = conn_iIndexFiles_2_iIndexer
							.prepareStatement(insert_iIndexFiles_2_iIndexer);

					/**
					 * [iIndexFiles_2_iIndexer begin ] stop
					 */

					/**
					 * [iIndexFiles_2_iFiles begin ] start
					 */

					ok_Hash.put("iIndexFiles_2_iFiles", false);
					start_Hash.put("iIndexFiles_2_iFiles", System
							.currentTimeMillis());
					currentComponent = "iIndexFiles_2_iFiles";

					int tos_count_iIndexFiles_2_iFiles = 0;

					String directory_iIndexFiles_2_iFiles = context.sourceDir;
					final java.util.List<String> maskList_iIndexFiles_2_iFiles = new java.util.ArrayList<String>();
					maskList_iIndexFiles_2_iFiles.add(context.include);
					int NB_FILEiIndexFiles_2_iFiles = 0;

					final boolean case_sensitive_iIndexFiles_2_iFiles = true;
					String excludefilemask_iIndexFiles_2_iFiles = context.exclude;
					final List<java.util.regex.Pattern> excludefilePathEachPattern_iIndexFiles_2_iFiles = new java.util.ArrayList<java.util.regex.Pattern>();
					if (excludefilemask_iIndexFiles_2_iFiles != null
							&& !"".equals(excludefilemask_iIndexFiles_2_iFiles)) {
						for (String excludefilemaskEach_iIndexFiles_2_iFiles : excludefilemask_iIndexFiles_2_iFiles
								.split(",")) {

							excludefilePathEachPattern_iIndexFiles_2_iFiles
									.add(java.util.regex.Pattern
											.compile(excludefilemaskEach_iIndexFiles_2_iFiles));

						}
					}
					final java.util.List<java.io.File> list_iIndexFiles_2_iFiles = new java.util.ArrayList<java.io.File>();
					java.io.File file_iIndexFiles_2_iFiles = new java.io.File(
							directory_iIndexFiles_2_iFiles);

					file_iIndexFiles_2_iFiles
							.listFiles(new java.io.FilenameFilter() {
								public boolean accept(java.io.File dir,
										String name) {
									java.io.File file = new java.io.File(dir,
											name);

									if (!file.isDirectory()) {

										String filePath_iIndexFiles_2_iFiles = file
												.getPath();
										for (final String filemask_iIndexFiles_2_iFiles : maskList_iIndexFiles_2_iFiles) {
											String filemask_compile_iIndexFiles_2_iFiles = filemask_iIndexFiles_2_iFiles;

											java.util.regex.Pattern filePathPattern_iIndexFiles_2_iFiles = java.util.regex.Pattern
													.compile(filemask_compile_iIndexFiles_2_iFiles);

											if (filePathPattern_iIndexFiles_2_iFiles
													.matcher(
															filePath_iIndexFiles_2_iFiles)
													.matches()) {
												boolean isExclude_iIndexFiles_2_iFiles = false;
												for (java.util.regex.Pattern pattern : excludefilePathEachPattern_iIndexFiles_2_iFiles) {
													if (pattern
															.matcher(
																	filePath_iIndexFiles_2_iFiles)
															.matches()) {
														isExclude_iIndexFiles_2_iFiles = true;
														break;
													}
												}
												if (!isExclude_iIndexFiles_2_iFiles) {
													list_iIndexFiles_2_iFiles
															.add(file);
												}
											}
										}
										return true;
									} else {
										file.listFiles(this);
									}

									return false;
								}
							});
					java.util.Collections.sort(list_iIndexFiles_2_iFiles);

					for (int i_iIndexFiles_2_iFiles = 0; i_iIndexFiles_2_iFiles < list_iIndexFiles_2_iFiles
							.size(); i_iIndexFiles_2_iFiles++) {
						java.io.File files_iIndexFiles_2_iFiles = list_iIndexFiles_2_iFiles
								.get(i_iIndexFiles_2_iFiles);
						String fileName_iIndexFiles_2_iFiles = files_iIndexFiles_2_iFiles
								.getName();

						String currentFileName_iIndexFiles_2_iFiles = files_iIndexFiles_2_iFiles
								.getName();
						String currentFilePath_iIndexFiles_2_iFiles = files_iIndexFiles_2_iFiles
								.getAbsolutePath();
						String currentFileDirectory_iIndexFiles_2_iFiles = files_iIndexFiles_2_iFiles
								.getParent();
						String currentFileExtension_iIndexFiles_2_iFiles = null;

						if (files_iIndexFiles_2_iFiles.getName().contains(".")
								&& files_iIndexFiles_2_iFiles.isFile()) {
							currentFileExtension_iIndexFiles_2_iFiles = files_iIndexFiles_2_iFiles
									.getName()
									.substring(
											files_iIndexFiles_2_iFiles
													.getName().lastIndexOf(".") + 1);
						} else {
							currentFileExtension_iIndexFiles_2_iFiles = "";
						}

						// Include tfileproperties fields in output so we don't
						// have to hook up tfileproperties to get them all the
						// time

						java.util.Date currentFileLastModified_iIndexFiles_2_iFiles = new java.util.Date(
								files_iIndexFiles_2_iFiles.lastModified());
						Double currentFileSize_iIndexFiles_2_iFiles = new Double(
								files_iIndexFiles_2_iFiles.length());

						NB_FILEiIndexFiles_2_iFiles++;

						globalMap.put("iIndexFiles_2_iFiles_CURRENT_FILE",
								currentFileName_iIndexFiles_2_iFiles);
						globalMap.put("iIndexFiles_2_iFiles_CURRENT_FILEPATH",
								currentFilePath_iIndexFiles_2_iFiles);
						globalMap.put(
								"iIndexFiles_2_iFiles_CURRENT_FILEDIRECTORY",
								currentFileDirectory_iIndexFiles_2_iFiles);
						globalMap.put(
								"iIndexFiles_2_iFiles_CURRENT_FILEEXTENSION",
								currentFileExtension_iIndexFiles_2_iFiles);
						globalMap
								.put(
										"iIndexFiles_2_iFiles_CURRENT_FILELASTMODIFIED",
										currentFileLastModified_iIndexFiles_2_iFiles);
						globalMap.put("iIndexFiles_2_iFiles_CURRENT_FILESIZE",
								currentFileSize_iIndexFiles_2_iFiles);

						globalMap.put("iIndexFiles_2_iFiles_NB_FILE",
								NB_FILEiIndexFiles_2_iFiles);

						/**
						 * [iIndexFiles_2_iFiles begin ] stop
						 */
						/**
						 * [iIndexFiles_2_iFiles main ] start
						 */

						currentComponent = "iIndexFiles_2_iFiles";

						row_iIndexFiles_2_iFiles.filePath = currentFilePath_iIndexFiles_2_iFiles;
						row_iIndexFiles_2_iFiles.fileLastModified = currentFileLastModified_iIndexFiles_2_iFiles;
						row_iIndexFiles_2_iFiles.fileSize = currentFileSize_iIndexFiles_2_iFiles;

						tos_count_iIndexFiles_2_iFiles++;

						/**
						 * [iIndexFiles_2_iFiles main ] stop
						 */

						/**
						 * [iIndexFiles_2_iIndexer main ] start
						 */

						currentComponent = "iIndexFiles_2_iIndexer";

						String resourceUrl_iIndexFiles_2_iIndexer = row_iIndexFiles_2_iFiles.filePath;
						java.util.Date modified_iIndexFiles_2_iIndexer = row_iIndexFiles_2_iFiles.fileLastModified;
						Double fileSize_iIndexFiles_2_iIndexer = row_iIndexFiles_2_iFiles.fileSize;

						// Index non-null resources

						if (url_iIndexFiles_2_iIndexer != null
								&& !url_iIndexFiles_2_iIndexer.trim()
										.equals("")) {
							// try to update an existing record

							if (modified_iIndexFiles_2_iIndexer != null) {
								pstmtUpdate_iIndexFiles_2_iIndexer
										.setTimestamp(1,
												new java.sql.Timestamp(
														modified_iIndexFiles_2_iIndexer
																.getTime()));
							} else {
								pstmtUpdate_iIndexFiles_2_iIndexer.setNull(1,
										java.sql.Types.TIMESTAMP);
							}

							pstmtUpdate_iIndexFiles_2_iIndexer.setDouble(2,
									fileSize_iIndexFiles_2_iIndexer);
							pstmtUpdate_iIndexFiles_2_iIndexer.setTimestamp(3,
									new java.sql.Timestamp(
											(new java.util.Date()).getTime()));
							pstmtUpdate_iIndexFiles_2_iIndexer.setLong(4,
									runNo_iIndexFiles_2_iIndexer);
							pstmtUpdate_iIndexFiles_2_iIndexer.setLong(5,
									jobId_iIndexFiles_2_iIndexer);
							pstmtUpdate_iIndexFiles_2_iIndexer.setString(6,
									resourceUrl_iIndexFiles_2_iIndexer);

							int updateFlag_iIndexFiles_2_iIndexer = pstmtUpdate_iIndexFiles_2_iIndexer
									.executeUpdate();

							// if no records where updated, insert a new record

							if (updateFlag_iIndexFiles_2_iIndexer == 0) {
								pstmtInsert_iIndexFiles_2_iIndexer.setLong(1,
										jobId_iIndexFiles_2_iIndexer);
								pstmtInsert_iIndexFiles_2_iIndexer.setString(2,
										resourceUrl_iIndexFiles_2_iIndexer);

								if (modified_iIndexFiles_2_iIndexer != null) {
									pstmtInsert_iIndexFiles_2_iIndexer
											.setTimestamp(3,
													new java.sql.Timestamp(
															modified_iIndexFiles_2_iIndexer
																	.getTime()));
								} else {
									pstmtInsert_iIndexFiles_2_iIndexer.setNull(
											3, java.sql.Types.TIMESTAMP);
								}

								pstmtInsert_iIndexFiles_2_iIndexer.setDouble(4,
										fileSize_iIndexFiles_2_iIndexer);
								pstmtInsert_iIndexFiles_2_iIndexer
										.setTimestamp(5,
												new java.sql.Timestamp(
														(new java.util.Date())
																.getTime()));
								pstmtInsert_iIndexFiles_2_iIndexer.setLong(6,
										runNo_iIndexFiles_2_iIndexer);

								pstmtInsert_iIndexFiles_2_iIndexer
										.executeUpdate();
							}

							// commit every specified number of records

							commitCounter_iIndexFiles_2_iIndexer++;

							if (commitEvery_iIndexFiles_2_iIndexer <= commitCounter_iIndexFiles_2_iIndexer) {
								conn_iIndexFiles_2_iIndexer.commit();
								commitCounter_iIndexFiles_2_iIndexer = 0;
							}

							// keep track of how many resources we've written
							nb_line_iIndexFiles_2_iIndexer++;
						}

						tos_count_iIndexFiles_2_iIndexer++;

						/**
						 * [iIndexFiles_2_iIndexer main ] stop
						 */

						/**
						 * [iIndexFiles_2_iFiles end ] start
						 */

						currentComponent = "iIndexFiles_2_iFiles";

					}
					globalMap.put("iIndexFiles_2_iFiles_NB_FILE",
							NB_FILEiIndexFiles_2_iFiles);

					ok_Hash.put("iIndexFiles_2_iFiles", true);
					end_Hash.put("iIndexFiles_2_iFiles", System
							.currentTimeMillis());

					/**
					 * [iIndexFiles_2_iFiles end ] stop
					 */

					/**
					 * [iIndexFiles_2_iIndexer end ] start
					 */

					currentComponent = "iIndexFiles_2_iIndexer";

					// commit records which haven't been committed yet
					conn_iIndexFiles_2_iIndexer.commit();
				} finally {
					// ensure connection is always closed
					if (conn_iIndexFiles_2_iIndexer != null) {
						conn_iIndexFiles_2_iIndexer.rollback();
						conn_iIndexFiles_2_iIndexer.close();
						conn_iIndexFiles_2_iIndexer = null;
					}
				}

				ok_Hash.put("iIndexFiles_2_iIndexer", true);
				end_Hash.put("iIndexFiles_2_iIndexer", System
						.currentTimeMillis());

				/**
				 * [iIndexFiles_2_iIndexer end ] stop
				 */

			}// end the resume

			if (resumeEntryMethodName == null || globalResumeTicket) {
				resumeUtil.addLog("CHECKPOINT",
						"CONNECTION:SUBJOB_OK:iIndexFiles_2_iFiles:OnSubjobOk",
						"", Thread.currentThread().getId() + "", "", "", "",
						"", "");
			}

			iHarvestResources_1Process(globalMap);

		} catch (java.lang.Exception e) {

			throw new TalendException(e, currentComponent, globalMap);

		} catch (java.lang.Error error) {

			throw new java.lang.Error(error);

		}

		globalMap.put("iIndexFiles_2_iFiles_SUBPROCESS_STATE", 1);
	}

	public String resuming_logs_dir_path = null;
	public String resuming_checkpoint_path = null;
	public String parent_part_launcher = null;
	private String resumeEntryMethodName = null;
	private boolean globalResumeTicket = false;

	public boolean watch = false;
	// portStats is null, it means don't execute the statistics
	public Integer portStats = null;
	public int portTraces = 4334;
	public String clientHost;
	public String defaultClientHost = "localhost";
	public String contextStr = "Default";
	public boolean isDefaultContext = true;
	public String pid = "0";
	public String rootPid = null;
	public String fatherPid = null;
	public String fatherNode = null;
	public long startTime = 0;
	public boolean isChildJob = false;

	private boolean execStat = true;

	private ThreadLocal threadLocal = new ThreadLocal();
	{
		java.util.Map threadRunResultMap = new java.util.HashMap();
		threadRunResultMap.put("errorCode", null);
		threadRunResultMap.put("status", "");
		threadLocal.set(threadRunResultMap);
	}

	private java.util.Properties context_param = new java.util.Properties();
	public java.util.Map<String, Object> parentContextMap = new java.util.HashMap<String, Object>();

	public String status = "";

	public static void main(String[] args) {
		final HarvestMetadataFileSystem_RT HarvestMetadataFileSystem_RTClass = new HarvestMetadataFileSystem_RT();

		int exitCode = HarvestMetadataFileSystem_RTClass.runJobInTOS(args);

		System.exit(exitCode);
	}

	public String[][] runJob(String[] args) {

		int exitCode = runJobInTOS(args);
		String[][] bufferValue = new String[][] { { Integer.toString(exitCode) } };

		return bufferValue;
	}

	public int runJobInTOS(String[] args) {

		String lastStr = "";
		for (String arg : args) {
			if (arg.equalsIgnoreCase("--context_param")) {
				lastStr = arg;
			} else if (lastStr.equals("")) {
				evalParam(arg);
			} else {
				evalParam(lastStr + " " + arg);
				lastStr = "";
			}
		}

		if (clientHost == null) {
			clientHost = defaultClientHost;
		}

		if (pid == null || "0".equals(pid)) {
			pid = TalendString.getAsciiRandomString(6);
		}

		if (rootPid == null) {
			rootPid = pid;
		}
		if (fatherPid == null) {
			fatherPid = pid;
		} else {
			isChildJob = true;
		}

		try {
			// call job/subjob with an existing context, like:
			// --context=production. if without this parameter, there will use
			// the default context instead.
			java.io.InputStream inContext = HarvestMetadataFileSystem_RT.class
					.getClassLoader().getResourceAsStream(
							"anfog_dm/harvestmetadatafilesystem_rt_0_1/contexts/"
									+ contextStr + ".properties");
			if (isDefaultContext && inContext == null) {

			} else {
				if (inContext != null) {
					// defaultProps is in order to keep the original context
					// value
					defaultProps.load(inContext);
					inContext.close();
					context = new ContextProperties(defaultProps);
				} else {
					// print info and job continue to run, for case:
					// context_param is not empty.
					System.err.println("Could not find the context "
							+ contextStr);
				}
			}

			if (!context_param.isEmpty()) {
				context.putAll(context_param);
			}

			context.logDir = (String) context.getProperty("logDir");

			context.paramFile = (String) context.getProperty("paramFile");

			context.metadataDb_RT_Database = (String) context
					.getProperty("metadataDb_RT_Database");

			context.metadataDb_RT_Login = (String) context
					.getProperty("metadataDb_RT_Login");

			context.metadataDb_RT_Password = (java.lang.String) context
					.getProperty("metadataDb_RT_Password");

			context.metadataDb_RT_Port = (String) context
					.getProperty("metadataDb_RT_Port");

			context.metadataDb_RT_Schema = (String) context
					.getProperty("metadataDb_RT_Schema");

			context.metadataDb_RT_Server = (String) context
					.getProperty("metadataDb_RT_Server");

			context.exclude = (String) context.getProperty("exclude");

			try {
				context.fileId = routines.system.ParserUtils
						.parseTo_Long(context.getProperty("fileId"));
			} catch (NumberFormatException e) {
				context.fileId = null;
			}

			context.include = (String) context.getProperty("include");

			context.sourceDir = (String) context.getProperty("sourceDir");

			context.url = (String) context.getProperty("url");

		} catch (java.io.IOException ie) {
			System.err.println("Could not load context " + contextStr);
			ie.printStackTrace();
		}

		// get context value from parent directly
		if (parentContextMap != null && !parentContextMap.isEmpty()) {
			if (parentContextMap.containsKey("logDir")) {
				context.logDir = (String) parentContextMap.get("logDir");
			}
			if (parentContextMap.containsKey("paramFile")) {
				context.paramFile = (String) parentContextMap.get("paramFile");
			}
			if (parentContextMap.containsKey("metadataDb_RT_Database")) {
				context.metadataDb_RT_Database = (String) parentContextMap
						.get("metadataDb_RT_Database");
			}
			if (parentContextMap.containsKey("metadataDb_RT_Login")) {
				context.metadataDb_RT_Login = (String) parentContextMap
						.get("metadataDb_RT_Login");
			}
			if (parentContextMap.containsKey("metadataDb_RT_Password")) {
				context.metadataDb_RT_Password = (java.lang.String) parentContextMap
						.get("metadataDb_RT_Password");
			}
			if (parentContextMap.containsKey("metadataDb_RT_Port")) {
				context.metadataDb_RT_Port = (String) parentContextMap
						.get("metadataDb_RT_Port");
			}
			if (parentContextMap.containsKey("metadataDb_RT_Schema")) {
				context.metadataDb_RT_Schema = (String) parentContextMap
						.get("metadataDb_RT_Schema");
			}
			if (parentContextMap.containsKey("metadataDb_RT_Server")) {
				context.metadataDb_RT_Server = (String) parentContextMap
						.get("metadataDb_RT_Server");
			}
			if (parentContextMap.containsKey("exclude")) {
				context.exclude = (String) parentContextMap.get("exclude");
			}
			if (parentContextMap.containsKey("fileId")) {
				context.fileId = (Long) parentContextMap.get("fileId");
			}
			if (parentContextMap.containsKey("include")) {
				context.include = (String) parentContextMap.get("include");
			}
			if (parentContextMap.containsKey("sourceDir")) {
				context.sourceDir = (String) parentContextMap.get("sourceDir");
			}
			if (parentContextMap.containsKey("url")) {
				context.url = (String) parentContextMap.get("url");
			}
		}

		// Resume: init the resumeUtil
		resumeEntryMethodName = ResumeUtil
				.getResumeEntryMethodName(resuming_checkpoint_path);
		resumeUtil = new ResumeUtil(resuming_logs_dir_path, isChildJob, rootPid);
		resumeUtil.initCommonInfo(pid, rootPid, fatherPid, projectName,
				jobName, contextStr, jobVersion);

		// Resume: jobStart
		resumeUtil.addLog("JOB_STARTED", "JOB:" + jobName,
				parent_part_launcher, Thread.currentThread().getId() + "", "",
				"", "", "", resumeUtil.convertToJsonText(context));

		long startUsedMemory = Runtime.getRuntime().totalMemory()
				- Runtime.getRuntime().freeMemory();
		long endUsedMemory = 0;
		long end = 0;

		startTime = System.currentTimeMillis();

		this.globalResumeTicket = true;// to run tPreJob

		this.globalResumeTicket = false;// to run others jobs

		try {
			errorCode = null;
			iPostgresqlDbUpdate_1Process(globalMap);
			if (!"failure".equals(status)) {
				status = "end";
			}
		} catch (TalendException e_iPostgresqlDbUpdate_1) {

			e_iPostgresqlDbUpdate_1.printStackTrace();
			globalMap.put("iPostgresqlDbUpdate_1_SUBPROCESS_STATE", -1);

		}

		this.globalResumeTicket = true;// to run tPostJob

		end = System.currentTimeMillis();

		if (watch) {
			System.out.println((end - startTime) + " milliseconds");
		}

		endUsedMemory = Runtime.getRuntime().totalMemory()
				- Runtime.getRuntime().freeMemory();
		if (false) {
			System.out
					.println((endUsedMemory - startUsedMemory)
							+ " bytes memory increase when running : HarvestMetadataFileSystem_RT");
		}

		int returnCode = 0;
		if (errorCode == null) {
			returnCode = status != null && status.equals("failure") ? 1 : 0;
		} else {
			returnCode = errorCode.intValue();
		}
		resumeUtil.addLog("JOB_ENDED", "JOB:" + jobName, parent_part_launcher,
				Thread.currentThread().getId() + "", "", "" + returnCode, "",
				"", "");

		return returnCode;

	}

	private void evalParam(String arg) {
		if (arg.startsWith("--resuming_logs_dir_path")) {
			resuming_logs_dir_path = arg.substring(25);
		} else if (arg.startsWith("--resuming_checkpoint_path")) {
			resuming_checkpoint_path = arg.substring(27);
		} else if (arg.startsWith("--parent_part_launcher")) {
			parent_part_launcher = arg.substring(23);
		} else if (arg.startsWith("--watch")) {
			watch = true;
		} else if (arg.startsWith("--stat_port=")) {
			String portStatsStr = arg.substring(12);
			if (portStatsStr != null && !portStatsStr.equals("null")) {
				portStats = Integer.parseInt(portStatsStr);
			}
		} else if (arg.startsWith("--trace_port=")) {
			portTraces = Integer.parseInt(arg.substring(13));
		} else if (arg.startsWith("--client_host=")) {
			clientHost = arg.substring(14);
		} else if (arg.startsWith("--context=")) {
			contextStr = arg.substring(10);
			isDefaultContext = false;
		} else if (arg.startsWith("--father_pid=")) {
			fatherPid = arg.substring(13);
		} else if (arg.startsWith("--root_pid=")) {
			rootPid = arg.substring(11);
		} else if (arg.startsWith("--father_node=")) {
			fatherNode = arg.substring(14);
		} else if (arg.startsWith("--pid=")) {
			pid = arg.substring(6);
		} else if (arg.startsWith("--context_param")) {
			String keyValue = arg.substring(16);
			int index = -1;
			if (keyValue != null && (index = keyValue.indexOf('=')) > -1) {
				if (fatherPid == null) {
					context_param.put(keyValue.substring(0, index),
							replaceEscapeChars(keyValue.substring(index + 1)));
				} else { // the subjob won't escape the especial chars
					context_param.put(keyValue.substring(0, index), keyValue
							.substring(index + 1));
				}
			}
		}

	}

	private final String[][] escapeChars = { { "\\n", "\n" }, { "\\'", "\'" },
			{ "\\r", "\r" }, { "\\f", "\f" }, { "\\b", "\b" }, { "\\t", "\t" },
			{ "\\\\", "\\" } };

	private String replaceEscapeChars(String keyValue) {
		if (keyValue == null || ("").equals(keyValue.trim())) {
			return keyValue;
		}
		for (String[] strArray : escapeChars) {
			keyValue = keyValue.replace(strArray[0], strArray[1]);
		}
		return keyValue;
	}

	public Integer getErrorCode() {
		return errorCode;
	}

	public String getStatus() {
		return status;
	}

	ResumeUtil resumeUtil = null;
}
/************************************************************************************************
 * 74704 characters generated by Talend Open Studio for Data Integration on the
 * January 15, 2014 1:09:04 PM EST
 ************************************************************************************************/
